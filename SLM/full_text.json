[
    {
        "Title": "Genetic Algorithm for Solving Simple Mathematical Equality Problem",
        "Full Text": "Genetic Algorithm for Solving Simple Mathematical Equality Problem  \nDenny Hermawanto  \nIndonesian Institute of Sciences (LIPI), INDONESIA  \nMail: denny.hermawanto@gmail.com  \n \nAbstract  \nThis paper explains genetic algorithm for novice in this field. Basic philosophy of genetic \nalgorithm and its flowchart are described. Step by step numerical computation of genetic \nalgorithm for solving simple mathematical equality problem will be briefly explained.  \n \nBasic Philosophy   \nGenetic algorithm developed by Goldberg was inspired by Darwin's theory of evolution \nwhich states that the survival of an organism is affected by rule \"the strongest species that \nsurvives\". Darwin also stated that the survival of an organism can be maint ained through the \nprocess of reproduction, crossover and mutation. Darwin's concept of evolution is then \nadapted to computational algorithm to find solution to a problem called objective function in \nnatural fashion. A solution generated by genetic algorith m is called a chromosome, while \ncollection of chromosome is referred as a population. A chromosome is composed from \ngenes and its value can be either numerical, binary, symbols or characters depending on the \nproblem want to be solved. These chromosomes wil l undergo a process called fitness \nfunction to measure the suitability of solution generated by GA with problem. Some \nchromosomes in population will mate through process called crossover thus producing new \nchromosomes named offspring which its genes compos ition are the combination of their \nparent. In a generation, a few chromosomes will also mutation in their gene. The number of \nchromosomes which will undergo crossover and mutation is controlled by crossover rate and \nmutation rate value. Chromosome in the p opulation that will maintain for the next generation \nwill be selected based on Darwinian evolution rule, the chromosome which has higher fitness \nvalue will have greater probability of being selected again in the next generation. After \nseveral generations, the chromosome value will converges to a certain value which is the best \nsolution for the problem.  \n \nThe Algorithm  \nIn the genetic algorithm process is as follows  [1]:  \nStep 1.  Determine the number of chromosomes, generation, and mutation rate and crossover \nrate value  \nStep 2. Generate chromosome -chromosome number of the population, and the initialization \nvalue of the genes chromosome -chromosome with a random value  Step 3. Proc ess steps 4 -7 until the number of generations is met  \nStep 4. Evaluation of fitness value of chromosomes by calculating objective function  \nStep 5. Chromosomes selection  \nStep 6. Crossover  \nStep 7. Mutation  \nStep 8. Solution (Best Chromosomes)  \n \nThe flowcha rt of algorithm can be seen in Figure 1  \n \n \nFigure 1. Genetic algorithm flowch art \n \n \nNumerical Example  \nHere are examples of applications that use genetic algorithms to solve the problem of \ncombination. Suppose there is equality a + 2b + 3c + 4d = 30, genetic algorithm will be used \nto find the value of a, b, c, and d that satisfy the above equation. First we should formulate \nSolutionsChromosome\nChromosome\nChromosome\nChromosome\nEvaluation\n\\’ith Population\nRoulette wheelSelection\nCrossover\nMutation\nEnd ?\nBest Chromosome\nBest Solutioni=i+1N\nYencoding\nDecodingNext generationthe objective function, for this problem the objective is minimizing the value of function f(x) \nwhere f(x) = (( a + 2b + 3c + 4d) - 30). Since there are four variables in the equation, namely \na, b, c, and d, we can compose the chromosome as follow: To speed up the computation, we \ncan restrict that the values of variables a, b, c, and d are integers between 0 and 30.  \n \n \n \nStep 1. I nitialization  \nFor example we define the number of chromosomes in population are 6, then we generate \nrandom value of gene a, b, c, d for 6 chromosomes  \nChromosome [1] = [ a;b;c;d] = [12;05;23;08]  \nChromosome [2] = [a;b;c;d] = [02;21;18;03]  \nChromosome [3] = [a;b;c;d] = [10;04;13;14]  \nChromosome [4] = [a;b;c;d] = [20;01;10;06]  \nChromosome [5] = [a;b;c;d] = [01;04;13;19]  \nChromosome [6] = [a;b;c;d] = [20;05;17;01]  \n \nStep 2. Evaluation  \nWe compute the objective function value for each chromosome produced in initializa tion \nstep:  \nF_obj [1] = Abs(( 12 + 2*05 + 3*23 + 4*08 ) - 30)  \n   = Abs((12 + 10 + 69 + 32 ) - 30)  \n   = Abs(123 - 30)  \n   = 93  \nF_obj [2] = Abs((02 + 2*21 + 3*18 + 4*03) - 30)  \n  = Abs((02 + 42 + 54 + 12) - 30)  \n  = Abs(110 - 30)  \n  = 80  \nF_obj [3] = Abs((10 + 2*04 + 3*13 + 4*14) - 30)  \n  = Abs((10 + 08 + 39 + 56) - 30)  \n  = Abs(113 - 30)  \n  = 83  \nF_obj [4] = Abs((20 + 2*01 + 3*10 + 4*06) - 30)  \n  = Abs((20 + 02 + 30 + 24) - 30) \n  = Abs(76 - 30)  \n = 46 \nF_obj [5] = Abs((01 + 2*04 + 3*13 + 4*19) - 30)  \n  = Abs((01 + 08 + 39 + 76) - 30)  \n  = Abs(124 - 30)  \n  = 94  \nF_obj [6] = Abs((20 + 2*05 + 3*17 + 4*01) - 30)  \n  = Abs((20 + 10 + 51 + 04) - 30)  \na b c d  = Abs(85 - 30)  \n  = 55 \n \nStep 3. Selection  \n1. The fittest chromosomes have higher probability to be selected f or the next \ngeneration. To compute fitness probability we must compute the fitness of each \nchromosome. To avoid divide by zero problem, the value of F_obj  is added by 1.  \nFitness [1] = 1 / (1+ F_obj [1])  \n           = 1 / 94  \n           = 0.0106  \nFitness [2] = 1 / (1+ F_obj [2])  \n    = 1 / 81  \n    = 0.0123  \nFitness [3] = 1 / (1+ F_obj [3])  \n           = 1 / 84  \n    = 0.0119  \nFitness [4] = 1 / (1+ F_obj [4])  \n    = 1 / 47  \n    = 0.0213  \nFitness [5] = 1 / (1+ F_obj [5])  \n    = 1 / 95  \n    = 0.0105  \nFitness [6] = 1 / (1+ F_obj [6])  \n    = 1 / 56  \n    = 0.0179  \nTotal  = 0.0106 + 0.0123 + 0.0119 + 0.0213 + 0.0105 + 0.0179  \n          = 0.0845  \n \nThe probability for each chromosomes is formulated by: P[i] = Fitness [i] / Total  \nP[1] = 0.0106 / 0.0845  \n        = 0.1254  \nP[2] = 0.0123 / 0.0845  \n        = 0.1456  \nP[3] = 0.0119 / 0.0845  \n        = 0.1408  \nP[4] = 0.0213 / 0.0845  \n        = 0.2521  \nP[5] = 0.0105 / 0.0845  \n        = 0.1243  \nP[6] = 0.0179 / 0.0845  \n        = 0.2118  \n \nFrom the probabilities above we can see that Chr omosome 4 that has the highest fitness, this \nchromosome has highest probability to be selected for next generation chromosomes. For the selection process we use roulette wheel, for that we should compute the cumulative \nprobability values:  \nC[1] = 0.1254  \nC[2] = 0.1254 + 0.1456  \n         = 0.2710  \nC[3] = 0.1254 + 0.1456 + 0.1408  \n         = 0.4118  \nC[4] = 0.1254 + 0.1456 + 0.1408 + 0.2521  \n         = 0.6639  \nC[5] = 0.1254 + 0.1456 + 0.1408 + 0.2521 + 0.1243  \n         = 0.7882  \nC[6] = 0.1254 + 0.1456 + 0.1408 + 0.2521 + 0.1243 + 0.2118  \n         = 1.0  \n \nHaving calculated the cumulative probability of selection process using roulette -wheel can be \ndone. The process is to generate random number R in the range 0 -1 as follows.  \nR[1] = 0.201  \nR[2] = 0.284  \nR[3] = 0.099  \nR[4] = 0.822  \nR[5] = 0.398  \nR[6] = 0.501  \n \nIf random number R[1] is greater  than C[1] and smaller than C[2] then select \nChromosome [2] as a chromosome in the new population for next generation:  \nNewChromosome [1] = Chromosome [2]  \nNewChromosome [2] =  Chromosome [3]  \nNewChromosome [3] = Chromosome [1]  \nNewChromosome [4] = Chromosome [6]  \nNewChromosome [5] = Chromosome [3]  \nNewChromosome [6] = Chromosome [4] \n \nChromosome s in the population thus became:  \nChromosome [1] = [02;21;18;03]  \nChromosome [2] = [10;04;13;14]   \nChromosome [3] = [12;05;23;08]  \nChromosome [4] = [20;05;17;01]  \nChromosome [5] = [10;04;13;14]  \nChromosome [6] = [20;01;10;06]  \n \nIn this example, we use one -cut point, i.e. randomly select a position in the parent \nchromosome then exchanging sub -chromosome. Parent chromosome which will mate is \nrandomly selected and the number of mate Chromosomes is controlled using crossover_rate  \n(ρc) parameters. Pseudo -code for the crossover process is as follows:  begin  \n     k← 0;  \n     while( k<population ) do \n     R[k] = random (0-1); \n     if(R[k]< ρc) then  \n        select Chromosome [k] as parent;  \n     end;  \n     k = k + 1;  \n     end;  \nend; \n \nChromosome k will be selected as a parent if R[k]<ρc. Suppose we set that the crossover rate \nis 25%, then Chromosome number k will be selected for crossover if random generated value \nfor Chromosome k below 0.25. The process is as follows: First we generate  a random number \nR as the number of population.  \nR[1] = 0.191  \nR[2] = 0.259  \nR[3] = 0.760  \nR[4] = 0.006  \nR[5] = 0.159  \nR[6] = 0.340  \n \nFor random number R above, parents are Chromosome [1], Chromosome [4] and \nChromosome [5] will be selected for crossover.  \nChromosome [1] >< Chromosome [4]  \nChromosome [4] >< Chromosome [5]  \nChromosome [5] >< Chromosome [1] \n \nAfter chromosome selection, the next process is determining the position of the crossover \npoint. This is done by generating random numbers between 1 to (length of Chromosome – 1). \nIn this case, generated random numbers should be between 1 and 3. After we get the \ncrossover point, parents Chromosome will be cut at crossover point and its gens will be \ninterchanged. For example we generated 3 random number and we get : \nC[1] = 1  \nC[2] = 1  \nC[3] = 2  \n \nThen for first crossover, second crossover and third crossover, parent’s gens will be cut at \ngen number 1, gen number 1 and gen number 3 respectively, e.g.  \nChromosome [1] = Chromosome [1] >< Chromosome [4]  \n   = [02;21;18;03] > < [20;05;17;01]  \n   = [02;05;17;01]  \nChromosome [4] = Chromosome [4] >< Chromosome [5]  \n   = [20;05;17;01] >< [10;04;13;14]     = [20;04;13;14]  \nChromosome [5] = Chromosome [5] >< Chromosome [1]  \n   = [10;04;13;14] >< [02;21;18;03]  \n   = [10;04;18;03]  \n \nThus Chromo some population after experiencing a crossover process:  \nChromosome [1] = [02;05;17;01]  \nChromosome [2] = [10;04;13;14]  \nChromosome [3] = [12;05;23;08]  \nChromosome [4] = [20;04;13;14]  \nChromosome [5] = [10;04;18;03]  \nChromosome [6] = [20;01;10;06]  \n \nStep 5.  Mutation  \nNumber of chromosomes that have mutations in a population is determined by the \nmutation_ rate parameter. Mutation process is done by replacing the gen at random position \nwith a new value. The process is as follows. First we must calculate the tot al length of gen in \nthe population. In this case the total length of gen is total_gen  = \nnumber_of_gen_in_Chromosome  * number of population   \n= 4 * 6  \n= 24 \n \nMutation process is done by generating a random integer between 1 and total_gen (1 to 24). \nIf generate d random number is smaller than mutation_rate(ρm) variable then marked the \nposition of gen in chromosomes. Suppose we define ρm 10%, it is expected that 10% (0.1) of \ntotal_gen in the population that will be mutated:  \nnumber of mutations = 0.1 * 24  \n= 2.4  \n≈ 2 \n \nSuppose generation of random number yield 12 and 18 then the chromosome which have \nmutation are Chromosome number 3 gen number 4 and Chromosome 5 gen number 2. The \nvalue of mutated gens at mutation point is replaced by random number between 0 -30. \nSuppose  generated random number are 2 and 5 then Chromosome composition after mutation \nare: \nChromosome [1] = [02;05;17;01]  \nChromosome [2] = [10;04;13;14]  \nChromosome [3] = [12;05;23; 02]  \nChromosome [4] = [20;04;13;14]  \nChromosome [5] = [10; 05;18;03]  \nChromosome [6] = [20;01;10;06]  \n \nFinishing mutation process then we have one iteration or one generation of the genetic \nalgorithm. We can now evaluate the objective function after one generation:  Chromosome [1] = [02;05;17;01]  \nF_obj [1] = Abs(( 02 + 2*05 + 3*17 + 4*01 ) - 30)  \n  = Abs((2 + 10 + 51 + 4 ) - 30)  \n  = Abs(67 - 30)  \n  = 37 \nChromosome [2] = [10;04;13;14]  \nF_obj [2] = Abs(( 10 + 2*04 + 3*13 + 4*14 ) - 30)  \n  = Abs((10 + 8 + 33 + 56 ) - 30)  \n  = Abs(107 - 30)  \n  = 77 \nChromosome [3] = [12;05;23;02]  \nF_obj [3] = Abs(( 12 + 2*05 + 3*23 + 4*02 ) - 30)  \n  = Abs((12 + 10 + 69 + 8 ) - 30)  \n  = Abs(87 - 30)  \n  = 47 \nChromosome [4] = [20;04;13;14]  \nF_obj [4] = Abs(( 20 + 2*04 + 3*13 + 4*14 ) - 30)  \n  = Abs((20 + 8 + 39 + 56 ) - 30)  \n  = Abs(123 - 30)  \n  = 93 \nChromosome [5] = [10;05;18;03]  \nF_obj [5] = Abs(( 10 + 2*05 + 3*18 + 4*03 ) - 30)  \n  = Abs((10 + 10 + 54 + 12 ) - 30)  \n  = Abs(86 - 30)  \n  = 56 \nChromosome [6] = [20;01;10;06]  \nF_obj [6] = Abs(( 20 + 2*01 + 3*10 + 4*06 ) - 30)  \n  = Abs((20 + 2 + 30 + 24 ) - 30)  \n  = Abs( 76 - 30) \n  = 46 \nFrom the evaluation of new Chromosome we can see that the objective function is decreasing, \nthis means that we have better Chromosome or solution compared with previous \nChromosome generation. New Chromosomes for next iteration are:  \nChromoso me[1] = [02;05;17;01]  \nChromosome [2] = [10;04;13;14]  \nChromosome [3] = [12;05;23;02]  \nChromosome [4] = [20;04;13;14]  \nChromosome [5] = [10;05;18;03]  \nChromosome [6] = [20;01;10;06]  \n \nThese new Chromosomes will undergo the same process as the previous generation  of \nChromosomes such as evaluation, selection, crossover and mutation and at the end it produce \nnew generation of Chromosome for the next iteration. This process will be repeated until a predetermined number of generations. For this example, after running 50 generations, best \nchromosome is obtained:  \nChromosome = [07; 05; 03; 01]  \nThis means that: a = 7, b = 5, c = 3, d = 1  \nIf we use the number in the problem equation : \na + 2b + 3c + 4d = 30  \n7 + (2 * 5) + (3 * 3) + (4 * 1) = 30  \nWe can see that the value of variable a, b, c and d generated by genetic algorithm can satisfy \nthat equality.  \n \nREFERENCE  \n[1] Mitsuo Gen, Runwei Cheng, “Genetic Algorithms And Engineering Design”, John Wiley \n& Sons, 1997.  "
    },
    {
        "Title": "The new classes of the genetic algorithms are defined by nonassociative groupoids",
        "Full Text": " \n \n© 1990 Sverchkov S.R.  \n THE NEW CLASSES OF THE GENETIC ALGORITHMS ARE DEFINED BY \nNONASSOCIATIVE GROUPOIDS.  \n \nS. SVERCHKOV , NOVOSIBIRSK STATE UNIVERSITY  \n \n \nAbstract.  The genetic product of the groupoids, originating in the theory of DNA \nrecombination, is introduced. It permits a natural generalization of the classical genetic \nalgorithm. The full characterization of all three -element genetic groupoids gives an \napproach  to construct the new classes of genetic algorithms. In the conclusion,  we \nformulate some open problems in the theory of the genetic groupoids.  \n \n  \nMathematics Subject  Classification (2000).  18B40, 11Y16, 17D92.   \n \nKey words : not associative groupoids, genetic product of the groupoids , generalization of genetic algorithm, three -\nelement genetic groupoids . \n \n \n \n1. INTRODUCTION  \n \nBy a groupoid \n( , )G\n= we mean a non -empty set \nG  on which a binary (not necessary \nassociative) operation “\n ” is defined. A finite set \nA closed under the set of multiplications \n12{ , ,..., }n M\nis called \nn -groupoid\n1( ; ,..., )n A\n and the set\nA  is called the  solution space .  \nGenerally speaking any \nn - groupoid  \n defines  \n- algorithm , which is an analog of \nclassical genetic algori thm denoted throughout the paper by GA. Indeed, a ny operation of \n12{ , ,..., }n M\ndefines the children   \n, iia b b a A\n ,                                                         (1) \n \nfor any parents  elements  \n,a b A\n . Let us note that the operation (1) is a key process to obtain \nnew generations in the iterative process of GA. To define the full procedure of an algorithm, we \nhave to set up a fitness function for selection and the mutations .  Let \n:fA\n be an arbitrary \nfunction , which defines a fitness –based operator  of selection the elements of any subset  of\nA, \nand let \n:iAA\n be a finite set of the autoisomorphisms  (mutations ) of\nA. Then\n – algorithm \nhas the same scheme as GA  with the replacement of crossovers by the operations of \nM and with \nreplacement the genetic mutation  of GA  by\ni\n . Finally , to determine  an \n- algorithm  means \nsimply the definition of multiplication table of \nn -groupoid\n1( ; ,..., )n A\n . \nFor example, in GA we have the solution space\n11{( ,..., ) |  0 }n i i A a a a d\n   and \nn  splicing \noperations (crossovers) \n12{ , ,..., }n M\n on \nA  defined by rules  \n \n \n1 1 1 1 1 1 1 1 1 1 1( ,..., ), ( ,..., )     ( ,..., ) ( ,..., ) ( ,..., , ,..., ).n n n i n i i n a a a b b b A a a b b a a b b\n   (2)    \n                     \nThe splicing operations (2) define \nn -groupoid\n1 2 1 1( ; , ,..., ) ( ; ,..., )nn n d d d A\n .  We \ncall \n1 2 1( ; , ,..., )n n d d d\n the splicing \nn -groupoid. Therefore classical genetic algorithm  is a \n1 2 1( ; , ,..., )n n d d d\n\n-algorithm . It is easy to check that the splicing operations are associative  \n(see [1] for more details of splicing operations ), i.e.  \n \n, , , 1 1    ( ) ( )i i i i a b c A i n a b c a b c\n.  \n \n© 1990 Sverchkov S.R.  \n  \n \nHowever, a “mixture” of splicing operations is not associative. Indeed, we have  \n \n2 1 1 ((111) (101)) (000) (111) (000) (100)\n, \n2 1 2 (111) ((101) (000)) (111) (100) (110)\n, \nand  \n2 1 2 1 ((111) (101)) (000) (111) ((101) (000))\n. \n \nWe have to indicate  two more important properties of the splicing  \nn-groupoid s\n1 2 1( ; , ,..., )n n d d d\n\n. For every splicing operation \nM\n  , we have  \n \n           a A a a a\n,                                                   (3) \n,              a b A a b b a a b\n.                                            (4) \n \nThose natural  restriction s of the operations eliminate the repetitions in the genetic \nalgorithm process.  \n \nWe call a groupoid (\nn -groupoid ) idempotent  if it sat isfies (3 ); nowhere commutative  (see \n[2] for the definition)  if it satisfies (4 ); and genetic  if it satisfies (3) and (4 ). We will denote by \n()nGen\nthe class  of all genetic \nn -groupoids, for \nn\n ; by \n()\nnn\n Gen = Gen  the class of all \ngenetic \nn -groupoids , for all \nn\n . Set \n(1)\n Gen Gen . Consequently , every groupoid \n( ,  )i A\n Gen\nis a genetic semigroup. One can easily check that \n1 2 1( ; , ,..., )n n d d d\n is a genetic  \nn\n-groupoid .  \n \nNaturally, we have to consider only the genetic \nn -groupoid s on a way of the construction \nof new classes of genetic algorithms. Even so,  an \n – algorithm for a genetic \nn -groupoid of a \nlarge enough solution space has useless  meaning for the computer applications. The \nmultiplication table of such \nn -groupoids is too large to operate with. The obvious advantage of \nGA is simple st and easy computer applicable multiplication table (2 ) of splicing \nn -groupoids . \nTherefore, o ur goal is to invent  a construction of generating  the subclass es of \n  Gen  which \npreserves  those benefits of splicing \nn -groupoids . It will give us an approach  to construct the new \nclasses of genetic algorithms , which are computable  ones. \n \n2. GENETIC PRODUCT  \n \nLet \n( , ), ( , )A M B N\n   be a \nn-groupoid with the solution space\n{}i Aa\n , and with \nthe operations \n12{ , ,..., }n M\n ; and a\nm -groupoid with the solution space\n{}jb\nB , and with \noperations  \n12{ , ,..., }m N\n , respectively . Let us define the \n( 1)nm\n  operations on the set \n{( , ) | , } A B a b a A b B\nby the next rules:  \n \n              \n1( , ),                                     ,\n      ( , ) ( , ) ( , ),                                     1,\n( , ),       2 1.x\nx\nxna c d x n\na b c d a d x n\na b d n x n m\n                                 (5)                                        \n  \n \n© 1990 Sverchkov S.R.  \n  \n \n \nfor any  \n( , ),( , )a b c d A B\n . The obtained \n( 1)nm\n -groupoid \nG\n  with the operation set \n1 2 1{ , ,..., }nm M\nis called the genetic product  of \n  and \n .  \n \nIt follows immediately that genetic product preserves genetic property of the groupoids, that \nis  \n( ), ( )     ( 1)G n m n m\n   Gen Gen Gen\n. \n \nSet \n1( , ) ( ; ,..., )\nnn d n d d\n  .  The trivial case \n(0, )Gd  means simply the set \n{0,1,...,, } d\nwithout any operations. The genetic product of \n( , )AM\n and \n(0, )Gd is called the genetic \nextension of \n and it is denoted by\n( ) (0, )G G G d\n . It is clear from (5 ) that solution space \n( ) {( , ) | , 0 }G A a j a A j d\n defines\n( 1)n\n -groupoid  \n()G with the multiplication table:  \n \n( , ),   1 ,( , ) ( , )( , ),           ( 1).x\nxa b t x na j b ta t x n\n \n \nThe straightforward proo f provides us with useful  properties of the genetic product.  \n \nLemma 1 .  \n, ,     ( ) ( )G G G G\n         Gen\n,                            (6) \n \nand for the general case, we have \nGG\n   .   \n \n()G\n G= Gen,\nis a semigroup, and besides \n  \nG Gen . \n \n,          ( 1; , ) ( , ) ( , )G n m GA n m a b GA n a GA m b\n\n, \n \n(1, ) ( (0, )) (0, ) (0, )G GA d G G d G d G d\n, \n( , ) (...( (1, )...)\nnGA n d G G d\n , \n1(2 , ) (1, ) ... (1, )GG\nnG n d G d G d\n\n,    \n(2 1, ) (2 , ) (0, )G G n d G n d G d\n . \n \nLet \n1... ,  G G n i\n    Gen , and \n:ii\n be an autoisomorphism of \ni ,  then \n11( ,..., ) ( ,..., ( ),..., )G n i na a a a a\nis an autoisomorphism of \n:G\n .  \n \nConversely, suppose \n11( ,..., ) ( ( ),..., ( ))nn a a a a\n is an autoisomorphism of \n , then \n( ) ( )i i iaa\nis an autoisomorphism of \n,  1i in\n . \n \nThe autoisomorphism group \n()Aut of \n is fully defined by the autoisomorphism groups \n()i Aut\nof \n,  1i in\n  \n \n  \n \n© 1990 Sverchkov S.R.  \n We call \n1... ,  G G n i\n    Gen the genetic decomposition  of \n  into\n,1i in\n Gen\n. \n \n \n3. MAIN RESULTS  \n \n \nLet us note that the genetic product \n11... ( ... ; )G G n n i\n     of the genetic  \ngroupoids \n( , ),  1i i iA i n\n  provides  the simple  computer applicable multiplication rules by \nmodulo of the multiplication s of \n( , )i i iA\n . Indeed, from (5), (6 ) we have  \n \n11\n11\n1( ,..., , ,..., ),    2 ,,     ( ,..., ) ( ,..., )( ,...,( ),..., ), 2 1.i i n\ni i i n i n\ni i i na a b b i ka b A a a b ba a b b i k\n \n \nFrom this we conclude that the complexity of computer calculations of \n1...G G n\n   -\nalgorithm for small dimensions of the groupoids \ni (let us say\n4i\n ) is no substantially greater \nthan the complexity of classical GA (respectively , complexity of \n(2 ,2)GA n ). Moreover, the \ngenetic decomposition of  \n1...G G n\n   transfers us from \nGen  into \nGen  to operate with \nsingle operation  groupoids . And m oreover, by lemma 1, a ll mutations of \n1...G G n\n   is \ndefined by the autoisomorphisms of \ni . \n \nLet \n1...G G n\n    be the genetic product of arbitrary  finite genetic semigroups \n(associative genetic groupoids ) \n( , )i i iA\n . We first prove that  \n-algorithm  is a classical \ngenetic algorithm for a splicing  \n(2 1)n\n -groupoid .  \n \nThe semigroup \n(1 ; , )GA n m is called the rectangular band  of\n{ 1,..., } { 1,..., } nm\n . Obviously , \nthis semigroup  has a multiplication table \n( , ) ( , ) ( , )x y a b x b\n . For more details of the rectangular \nbands we refer the readers to [2, 3].  Let us denote by \nRBand  the class of the rectangular band s. \nIt is well known that any genetic semigroup is a rectangular  band , and the class \nRBand  is a \nvariety  defined by two identities  \n \n, ,    ( ) ( ),\n,             ( ) .a b c ab c a bc\na b ab a a\n                                                               (7) \n \nOn account of the above remark, we obtain a  characterization of a genetic decomposition  of\n\n into the associative genetic groupoids  (genetic semigroups) . \nTheorem  1. Let \n( , ),   1i i iA i n\n  be a family of finite genetic semigroups then \n1 1 2... (2 1; ,..., )G G n n G n d d\n   \nfor some  \nid\n . \n \nConsequently, there are no new classes of genetic algorithms in associative case. \nTherefore, to obtain a generalization of GA  if it any exists , we have to describe non associative \ngenetic groupoids of the small dimensions .  The procedure (1) of creating new generations in \n -\nalgorithm shows that it is sufficient to characterize groupoids  up to isomorphism and anti -\nisomorphism . We will do it for three –element  ones.   \n \n© 1990 Sverchkov S.R.  \n  \nIt is easy to check  that any two element genetic groupoid is a semigroup, i.e. they are in the \nvariety  \nRBand . It follows that we have to deal with at least 3-elemen t groupoids.  By a \ncomputer study, all non -isomorphic 3 -elemen t groupoids were described in [4 ]. There are 3330 \nof them. It is too much even to observe them. Fortunat ely, the class \n3Gen of genetic (not \nisomorphic or anti - isomorphic) 3-elemen t groupoids consists only of 18 groupoids. A \ncharacterization of \n3Gen  can be easily made by “hand ” calculations .  \n \nLet us denote by \n,  , ,i j ki x j y k zx y z\n the genetic groupoid \n1 2 3({ , , }, )A a a a\nwith multiplication table \n1\n2\n3ij\nxk\nyza a a\na a a\na a a\n .   \n \nDirectly a pplying only three automorphisms (permutations) \n:ij i jaa\n to the  \nmultiplication table of  \n1 2 3({ , , }, )A a a a\n we  obtain the description of \n3Gen .  \n \nSet \n{ ,1 17}iAi\n M = \n=\n000 000 000 000 000 000 000 000 100, , , , , , , , ,111 222 112 121 211 221 212 122 221\n  \n \n011 011 002 020 200 111 111 111, , , , , , ,122 221 121 112 112 020 200 002\n. \n \n \nTheorem 2.   \n3001\n122\n Gen M .  \nThe class \nM consists of all three –element genetic nonassociative groupoids up to \nisomorphism or anti - isomorphism. There is only one three –element genetic associative groupoid  \nin \n3Gen . It is a  semigroup \n001\n122\nRBand , and i t is precisely the rectangular band of\n{ 1 } { 1,2,3}\n. \n \n Application  of Theorem 2 gives us the new classes of computer applicable \n1...G G m\n  \n-algorithm s. They are strictly nonassociative \n -algorithms f or\n iAm\n  M,\n, and partially associative \n - algorithm s for \n{ (0, )}i\ndA G d\nM . \n \n4. CONCLUSION  \n \nIt is clear that the class \nGen  of all genetic groupoids  defines all natural generalizations of th e \nclassical genetic algorithms, by modulo of the genetic  decomposition . Therefore, any \ncharacterization of \nGen may be an extremely useful. One can check  that \nGen  forms a quasi -\nvariety defined by the identity (3) and quasi -identity (4 ).    \n \n© 1990 Sverchkov S.R.  \n  \nIt is not hard to see that \nGen does not form a variety. It is closed under formation of \nsubgroupoids and direct products , but not of homomorphic images. The homomorphic image of \ngenetic groupoid \n000\n111\n , defined by \n01aa\n , is not genetic. From this it follows that the class \nGen\ncan’t be defined  by any set of identities. B ut there are some subvarieties in \nGen . For \nexample \nRBand Gen , by (7).  \n \nFrom the above remarks, one may set up some problems, whose answers aren’t known to \nauthor.  \n \nProblem 1. Describe maximal subvarieties  of \nGen . \n \nThe variety  \nRBand  has an elegant and complete description of the lattice  of the all \nsubvarieties (see [5 ] for more details). In particular, it is countable , complete , and distributive .   \n \nProblem 2. Describe the lattice of the all subvarieties of \nGen . \n \n \n \nREFERENCES  \n \n \n[1] Sverchkov, S. R . (2009 ), “Structure and representations of Jordan algebras arising from \nintermolecular recombination ”, Contemporary Mathematics, American Mathematical Socie ty, \n483: 261-285. \n \n[2] Clifford, A. H. ; Preston, G. B.  (1961), The algebraic theory of semigroups, vol. 1, American \nMathematical Society.  \n \n[3] Howie, J.M.  (1976), An introduction to semigroup theory, Academic Press.  \n \n[4] Berman, J.;  Burris, S. (1996), “A computer  study of 3 -element groupoids”, Proceedings of  \nthe Magari Conference, Marcel Dekker Inc.: 379-430. \n \n[5] Biryukov, A. P. (1970), \"Varieties of idempotent semigroups\", Algebra and Logic 9 (3): 153 –\n164. \n \n \n \n \n \nS. SVERCHKOV,  \nNOVOSIBIRSK STATE UNIVERSITY ,  \ne-mail: sverchkovsr@yandex.ru  "
    }
]